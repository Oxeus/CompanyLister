In the beginning when I wrote the design document, I had an ADT that composed of a linked list of linked lists where the top list had it owns class and the lists inside the linked lists had its own class. I decided to just use two structs instead of two classes. So, my ADT was controlled only by one class. From my perspective the data structure selected performed very admirably. What we needed for the assignment was the ability to keep track of locations and keep track of the jobs at each location. This basically means we needed two lists where one list was attached to each location. The list format worked because the list format allowed fast access to the data we needed without having the load the whole structure.
I would say that an array of arrays, or an array of lists could probably work if the program needed fast access to specific content. These data structures wouldn’t work space wise because you would have to load the entire data structure before you can have access to one specific element, this take time to do. Easy access is good for a data structure, but you also need to have fast load time and having the structure take time to load slows down the program. If we wanted to, we could keep the linked list of linked lists and use an array of pointers to keep track of each location or specific locations to speed up load time while traversing in a large list.
I believe that my design was efficient because most of my functions only had one traversal unless it was a function that had to use my find function. For instance, for addLocation I needed two traversal, one traversal to find out if the location already existed and another traversal to add the location to the list if location was not present. To my knowledge all my other functions only took one traversal down the lists they needed. I think that it was efficient to send all the data using a struct object instead of multiple arguments to clean up clutter.
For my design to make it more efficient I could figure out a way to combine the find and add functions together. To do this I could traverse through the list looking for the location, and if the location is not where it’s supposed to be than add it to the list. For instance, if I had a list of (1,2,4,5) and I wanted to add 3 the function would traverse and do a comparison, if the location was in the list the node wouldn’t be added and if the location was not in the list then the function would add the node there. This would cut down on the number of traversals that are made by combining two different traversals jobs together.
To simplify the size and memory usage of the functions I would try to use more recursion to process the data, doing this could involve using pass by reference. I would still have to figure out how to use recursion on a linked list of linked lists, I can recurse down the top list, but I would have to think of a way to recurse down the lists located at each node of the top list. I could also add a feature to delete a whole location and its list, whether full or empty, for easier management, I want to do this because currently when my program deletes the only node in a job list, the location node is still left in the data structure. I could also implement the edit job function to allow the user to edit any field if they didn’t leave it blank in main. If the location or name was changed then that would require moving the node in the location list and job list. Alternatively, I could deep copy the node, send the copy to addJob, then delete the node that was being edited saving myself from having to manually move the node.

